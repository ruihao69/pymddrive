# %% The package: pymddrive.integrators.state
import numpy as np

from numpy.typing import ArrayLike, DTypeLike
from typing import Any, Union

from pymddrive.utils import is_hermitian_matrix

class State:
    dim_classical: Union[int, None]
    dim_quantum: Union[int, None]
    dtype: DTypeLike
    
    def __repr__(self) -> str:
        return "State Default Class"
    
    def __add__(self, other):
        pass
    
    def __sub__(self, other):
        pass
    
    def __mul__(self, other):
        pass
    
    def __lmul__(self, other):
        pass
    
    def __rmul__(self, other):
        pass
    
    def __iadd__(self, other):
        pass
    
    def flatten(self):
        pass
    
    def get_dimclassical(self):
        return self.dim_classical
    
    def get_dimquantum(self):
        return self.dim_quantum
    
def verify_classical_dim(
    r: Union[None, float, ArrayLike], 
    p: Union[None, float, ArrayLike], 
    dim_classical: int
):
    if r is None or p is None:
        return True
    if r is None and p is None:
        return True
    elif isinstance(r, float):
        if isinstance(p, float):
            if (dim_classical == 1) or (dim_classical is None):
                return True
            else:
                raise ValueError(f"Dimension of the classical state is not consistent: {dim_classical} != 1")
        else:
            raise TypeError(f"Type of P is not consistent with R: type R({type(r)}) != type P({type(p)})")
            
    elif isinstance(r, np.ndarray):
        if isinstance(p, np.ndarray):
            if r.shape == p.shape:
                if (r.shape[0] == dim_classical) or (dim_classical is None):
                    return True
                else:
                    raise ValueError(f"Dimension of the classical state is not consistent: {r.shape[0]} != {dim_classical}")
            else:
                raise ValueError(f"Dimensions of R and P are not consistent: dim R({r.shape}) != dim P({p.shape})")
        else:
            raise TypeError(f"Type of P is not consistent with R: type R({type(r)}) != type P({type(p)})") 
    else:
        raise TypeError(f"The type of R and P shall be either float or np.ndarray, yet the type of them are type R({type(r)}), type P({type(p)}.")
            

class StateClassical(State):  
    def __init__(
        self, 
        r: Union[None, float, ArrayLike], 
        p: Union[None, float, ArrayLike],
        dim_classical: int = None,
        *args,
        **kwargs
    ) -> None:
        self.dim_quantum = None
        # Check the consistency of cl
        if r is None and p is None and dim_classical is None:
            raise ValueError("The classical state cannot be determined.") 
        
        verify_classical_dim(r, p, dim_classical)
        
        if (r is None and p is None) and isinstance(dim_classical, int) and (dim_classical > 0):
            self.dim_classical = dim_classical
        else:
            self.dim_classical = r.shape[0] 
            
        self.dtype = [
            ('R', np.float64, self.dim_classical), 
            ('P', np.float64, self.dim_classical)
        ]
        
        self.state = np.zeros(1, dtype=self.dtype)
        if r is not None:
            self.state['R'][:] = r
        if p is not None:
            self.state['P'][:] = p
     
    def __repr__(self) -> str:
        return f"StateClassical(type: {self.dtype}, dims: {self.state.shape})"
    
    def __add__(self, other: "StateClassical") -> "StateClassical":
        if isinstance(other, StateClassical):
            return StateClassical(
                r=(self.state['R'] + other.state['R']).reshape(self.dim_classical), 
                p=(self.state['P'] + other.state['P']).reshape(self.dim_classical)
            )
    
    def __sub__(self, other: "StateClassical") -> "StateClassical":
        if isinstance(other, StateClassical):
            return StateClassical(
                r=(self.state['R'] - other.state['R']).reshape(self.dim_classical),
                p=(self.state['P'] - other.state['P']).reshape(self.dim_classical)
            )
    
    def __mul__(self, scalar: Union[float, complex, int]) -> "StateClassical":
        if isinstance(scalar, (float, complex, int)):
            return StateClassical(
                r=scalar*self.state['R'].reshape(self.dim_classical), 
                p=scalar*self.state['P'].reshape(self.dim_classical)
            )
        else: 
            raise NotImplementedError("Multiplication of two states is not defined.")
    
    def __lmul__(self, scalar: Union[float, complex, int]) -> "StateClassical":
        return self.__mul__(scalar) 
    
    def __rmul__(self, scalar: Union[float, complex, int]) -> "StateClassical":
        return self.__mul__(scalar)
        
    def __iadd__(self, other: "StateClassical") -> "StateClassical":
        if isinstance(other, StateClassical):
            self.state['R'] += other.state['R']
            self.state['P'] += other.state['P']
            return self
        else:
            raise NotImplementedError(f"Addition between {type(self)} and {(type(other))} is not defined.")
        
    def flatten(self):
        return self.state.view(np.float64).reshape(-1)
    
def verify_quantum_dim(rho: Union[None, ArrayLike], dim_quantum: int):
    if rho is None:
        if dim_quantum is None:
            raise ValueError("The quantum state cannot be determined.")
        elif isinstance(dim_quantum, int) and (dim_quantum > 0):
            return True
        else: 
            raise ValueError(f"Invalid dimension of the quantum state: {dim_quantum}")
        
    if isinstance(rho, np.ndarray):
        if rho.shape[-1] == rho.shape[-2]:
            if (rho.shape[-1] == dim_quantum) or (dim_quantum is None):
                if is_hermitian_matrix(rho):
                    return True
                else:
                    raise ValueError("The quantum state (density matrix) is not a Hermitian matrix.")
            else:
                raise ValueError(f"Dimension of the quantum state is not consistent: {rho.shape[-1]} != {dim_quantum}")
        else:
            raise ValueError(f"The quantum state (density matrix) is not a square matrix: {rho.shape}")
 
class StateQuantum(State):
    def __init__(self, 
        rho: Union[None, ArrayLike], 
        dim_quantum: int = None,
        *args, 
        **kwargs
    ) -> None:
        self.dim_classical = None
        verify_quantum_dim(rho, dim_quantum)
        if rho is None and isinstance(dim_quantum, int) and (dim_quantum > 0):
            self.dim_quantum = dim_quantum
            
        if rho is not None:
            self.dim_quantum = rho.shape[-1]
            
        self.dtype = [
            ('rho', np.complex128, (self.dim_quantum, self.dim_quantum))
        ]
        
        self.state = np.zeros(1, dtype=self.dtype)
        
        if rho is not None:
            self.state['rho'][:] = rho[:]
    
    def __repr__(self) -> str:
        return f"StateQuantum(dim={self.rho.shape})"
    
    def __add__(self, other: "StateQuantum") -> "StateQuantum":
        if isinstance(other, StateQuantum):
            return StateQuantum(
                rho=(self.state['rho'] + other.state['rho']).reshape(self.dim_quantum, self.dim_quantum)
            )
        
    def __sub__(self, other: "StateQuantum") -> "StateQuantum":
        if isinstance(other, StateQuantum):
            return StateQuantum(
                rho=(self.state['rho'] - other.state['rho']).reshape(self.dim_quantum, self.dim_quantum)
            )
    
    def __mul__(self, scalar: Union[float, complex, int]) -> "StateQuantum":
        if isinstance(scalar, (float, complex, int)):
            return StateQuantum(
                rho=scalar*self.state['rho'].reshape(self.dim_quantum, self.dim_quantum)
            )
        if isinstance(scalar, StateQuantum):
            raise NotImplementedError("Multiplication of two states is not defined.")   
        
    def __lmul__(self, scalar: Union[float, complex, int]) -> "StateQuantum":   
        return self.__mul__(scalar) 
    
    def __rmul__(self, scalar: Union[float, complex, int]) -> "StateQuantum":
        return self.__mul__(scalar)
    
    def __iadd__(self, other: "StateQuantum") -> "StateQuantum":
        if isinstance(other, StateQuantum):
            self.state['rho'] += other.state['rho']
            return self
        else:
            raise NotImplementedError(f"Addition between {type(self)} and {(type(other))} is not defined.")
            
        
    def flatten(self):
        return self.state.view(np.complex128).reshape(-1)

class StateMQC(State):
    def __init__(
        self,
        r: Union[None, float, ArrayLike],
        p: Union[None, float, ArrayLike],
        rho: Union[None, ArrayLike],
        dim_classical: int = None,
        dim_quantum: int = None,
    ) -> None:
        verify_classical_dim(r, p, dim_classical)
        verify_quantum_dim(rho, dim_quantum)
        if r is None and p is None and dim_classical is None:
            raise ValueError("The classical part of the state cannot be determined.")
        
        if r is not None and isinstance(r, np.ndarray):
            self.dim_classical = r.shape[0]
        elif isinstance(r, float) or isinstance(r, int):
            self.dim_classical = 1
        else:
            self.dim_classical = dim_classical
        
        if rho is None and dim_quantum is None:
            raise ValueError("The quantum part of the state cannot be determined.")
        
        if rho is not None:
            self.dim_quantum = rho.shape[0]
        else:
            self.dim_quantum = dim_quantum
            
        self.dtype = [
            ('R', np.float64, self.dim_classical), 
            ('P', np.float64, self.dim_classical),
            ('rho', np.complex128, (self.dim_quantum, self.dim_quantum))
        ]
        
        self.state = np.zeros(1, dtype=self.dtype)
        if r is not None:
            self.state['R'][:] = r
        if p is not None:
            self.state['P'][:] = p
        if rho is not None:
            self.state['rho'][:] = rho
     
    def __repr__(self) -> str:
        return f"StateMQC(type: {self.dtype}, dims_cl: {self.dim_classical}, dims_qm: {self.dim_quantum})"    
    
    def __add__(self, other: "StateMQC") -> "StateMQC":
        if isinstance(other, StateMQC):
            return StateMQC(
                r=(self.state['R'] + other.state['R']).reshape(self.dim_classical), 
                p=(self.state['P'] + other.state['P']).reshape(self.dim_classical), 
                rho=(self.state['rho'] + other.state['rho']).reshape(self.dim_quantum, self.dim_quantum)
            )
    
    def __sub__(self, other: "StateMQC") -> "StateMQC":
        if isinstance(other, StateMQC):
            return StateMQC(
                r=(self.state['R'] - other.state['R']).reshape(self.dim_classical),
                p=(self.state['P'] - other.state['P']).reshape(self.dim_classical),
                rho=(self.state['rho'] - other.state['rho']).reshape(self.dim_quantum, self.dim_quantum)
            )
        
    def __mul__(self, scalar: Union[float, complex, int]) -> "StateMQC":
        if isinstance(scalar, (float, complex, int)):
            return StateMQC(
                r=scalar*self.state['R'].reshape(self.dim_classical), 
                p=scalar*self.state['P'].reshape(self.dim_classical),
                rho=scalar*self.state['rho'].reshape(self.dim_quantum, self.dim_quantum)
            )
        if isinstance(scalar, StateMQC):
            raise NotImplementedError("Multiplication of two states is not defined.")   
        
    def __lmul__(self, scalar: Union[float, complex, int]) -> "StateMQC":
        return self.__mul__(scalar)
    
    def __rmul__(self, scalar: Union[float, complex, int]) -> "StateMQC":
        return self.__mul__(scalar)
    
    def __iadd__(self, other: "StateMQC") -> "StateMQC":
        if isinstance(other, StateMQC):
            self.state['R'] += other.state['R']
            self.state['P'] += other.state['P']
            self.state['rho'] += other.state['rho']
            return self
        else:
            raise NotImplementedError(f"Addition between {type(self)} and {(type(other))} is not defined.")
        
    def flatten(self):
        return self.state.view(np.complex128).reshape(-1)
    
def zeros_like(s: State):
    if isinstance(s, StateClassical):
        return StateClassical(
            r=np.zeros_like(s.state['R']).reshape(s.dim_classical), 
            p=np.zeros_like(s.state['P']).reshape(s.dim_classical)
        )
    elif isinstance(s, StateQuantum):
        return StateQuantum(
            rho=np.zeros_like(s.state['rho']).reshape(s.dim_quantum, s.dim_quantum)
        )
    elif isinstance(s, StateMQC):
        return StateMQC(
            r=np.zeros_like(s.state['R']).reshape(s.dim_classical), 
            p=np.zeros_like(s.state['P']).reshape(s.dim_classical), 
            rho=np.zeros_like(s.state['rho']).reshape(s.dim_quantum, s.dim_quantum)
        )
    raise NotImplementedError(f"Unknown state type: {type(s)}")

# %% The temporary code snippet for the main function
if __name__ == "__main__":
    rho = np.array([[1, 2], [2, 1]], dtype=np.complex128)
    s = StateMQC(r=1.0, p=2.0, rho=rho)
    # print(s)
    # print(zeros_like(s))
    # print(s + s)
    # s += 0.5*s
    # print(s)
    # s1 = s
    # dtype = [('position', np.float64, 3), ('momentum', np.float64, 3)]
    # num_particles = 100  # Example: 100 particles
    # particles = np.zeros(num_particles, dtype=dtype)
    # print(particles[0]['position'])
    # concatenated_array = np.view(np.float64).reshape(-1, 6)
    # concatenated_array[:, :3] = particles['position']
    # concatenated_array[:, 3:] = particles['momentum']
    # concatenated_array = np.concatenate((particles['position'], particles['momentum']), axis=1)
    # print(concatenated_array.shape)
    # print(particles[0]['position'].shape)
    
# %%
