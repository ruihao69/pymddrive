# %% The package: pymddrive.integrators.state
from dataclasses import dataclass

import numpy as np

from numpy.typing import ArrayLike, DTypeLike
from typing import Any, Union
from numpy.lib import recfunctions as rfn

from pymddrive.utils import is_hermitian_matrix

def verify_classical_dim(
    r: Union[None, float, ArrayLike], 
    p: Union[None, float, ArrayLike], 
    dim_classical: int
):
    if r is None or p is None:
        return True
    if r is None and p is None:
        return True
    elif isinstance(r, float):
        if isinstance(p, float):
            if (dim_classical == 1) or (dim_classical is None):
                return True
            else:
                raise ValueError(f"Dimension of the classical state is not consistent: {dim_classical} != 1")
        else:
            raise TypeError(f"Type of P is not consistent with R: type R({type(r)}) != type P({type(p)})")
            
    elif isinstance(r, np.ndarray):
        if isinstance(p, np.ndarray):
            if r.shape == p.shape:
                if (r.shape[0] == dim_classical) or (dim_classical is None):
                    return True
                else:
                    raise ValueError(f"Dimension of the classical state is not consistent: {r.shape[0]} != {dim_classical}")
            else:
                raise ValueError(f"Dimensions of R and P are not consistent: dim R({r.shape}) != dim P({p.shape})")
        else:
            raise TypeError(f"Type of P is not consistent with R: type R({type(r)}) != type P({type(p)})") 
    else:
        raise TypeError(f"The type of R and P shall be either float or np.ndarray, yet the type of them are type R({type(r)}), type P({type(p)}.")
            



def verify_quantum_dim(rho: Union[None, ArrayLike], dim_quantum: int):
    if rho is None:
        if dim_quantum is None:
            raise ValueError("The quantum state cannot be determined.")
        elif isinstance(dim_quantum, int) and (dim_quantum > 0):
            return True
        else: 
            raise ValueError(f"Invalid dimension of the quantum state: {dim_quantum}")
        
    if isinstance(rho, np.ndarray):
        if rho.shape[-1] == rho.shape[-2]:
            if (rho.shape[-1] == dim_quantum) or (dim_quantum is None):
                if is_hermitian_matrix(rho):
                    return True
                else:
                    raise ValueError("The quantum state (density matrix) is not a Hermitian matrix.")
            else:
                raise ValueError(f"Dimension of the quantum state is not consistent: {rho.shape[-1]} != {dim_quantum}")
        else:
            raise ValueError(f"The quantum state (density matrix) is not a square matrix: {rho.shape}")
 

@dataclass
class State:
    dim_classical: int
    dim_quantum: int
    dtype: DTypeLike
    data: ArrayLike
    init_from_self: bool = False
    
    def __repr__(self) -> str:
        return "State Default Class"
    
    def __add__(self, other):
        data_this = rfn.structured_to_unstructured(self.data, copy=False)
        data_other = rfn.structured_to_unstructured(other.data, copy=False)
        return type(self)(
            r=None,
            p=None,
            rho=None,
            dim_classical=self.dim_classical,
            dim_quantum=self.dim_quantum,
            dtype=self.dtype,
            data=rfn.unstructured_to_structured(data_this + data_other, dtype=self.dtype)
        )
    
    def __sub__(self, other):
        data_this = rfn.structured_to_unstructured(self.data, copy=False)
        data_other = rfn.structured_to_unstructured(other.data, copy=False)
        return type(self)(
            r=None,
            p=None,
            rho=None,
            dim_classical=self.dim_classical,
            dim_quantum=self.dim_quantum,
            dtype=self.dtype,
            data=rfn.unstructured_to_structured(data_this - data_other, dtype=self.dtype)
        )
    
    def __mul__(self, scalar: Union[float, int, complex]):
        data_this = rfn.structured_to_unstructured(self.data, copy=False)
        if isinstance(scalar, (float, int, complex)):
            return type(self)(
                r=None,
                p=None,
                rho=None,
                dim_classical=self.dim_classical,
                dim_quantum=self.dim_quantum,
                dtype=self.dtype,
                data=rfn.unstructured_to_structured(data_this * scalar, dtype=self.dtype)
            )
        else:
            raise TypeError(f"Invalid type of scalar: {type(scalar)}")
    
    def __lmul__(self, other):
        return self.__mul__(other)
    
    def __rmul__(self, other):
        return self.__mul__(other)
    
    def __iadd__(self, other):
        data_this = rfn.structured_to_unstructured(self.data, copy=False)
        data_other = rfn.structured_to_unstructured(other.data, copy=False)
        self.data = rfn.unstructured_to_structured(data_this + data_other, dtype=self.dtype)
        return self
    
    def flatten(self):
        return rfn.structured_to_unstructured(self.data, copy=False).reshape(-1)
    
    def get_dimclassical(self):
        return self.dim_classical
    
    def get_dimquantum(self):
        return self.dim_quantum

class StateClassical(State):  
    def __init__(
        self, 
        dim_classical: int = None,
        dim_quantum: int = None,
        dtype: DTypeLike = None,
        data: ArrayLike = None,
        *args,
        **kwargs
    ) -> None:
        if self.init_from_self:
            print("init_from_self is called")
            super().__init__(self.dim_classical, self.dim_quantum, self.dtype, self.data)
            self.init_from_self = False
        else:
            super().__init__(dim_classical, dim_quantum, dtype, data, )
        
    def __new__(
        cls, 
        r: Union[None, float, ArrayLike], 
        p: Union[None, float, ArrayLike], 
        dim_classical: int = None,
        *args,
        **kwargs
    ) -> "StateClassical":
        # The quick route out, no r and p is given
        if "data" in kwargs and r is None and p is None:
            return super(StateClassical, cls).__new__(cls)
        
        dim_quantum = None
        
        # Check the consistency of cl
        if r is None and p is None and dim_classical is None:
            raise ValueError("The classical state cannot be determined.") 
        
        verify_classical_dim(r, p, dim_classical)
        
        if (r is None and p is None) and isinstance(dim_classical, int) and (dim_classical > 0):
            pass
        elif isinstance(r, float):
            dim_classical = 1
        else:
            dim_classical = r.shape[0] 
            
        dtype = [
            ('R', np.float64, dim_classical), 
            ('P', np.float64, dim_classical)
        ]
        
        data = np.zeros(1, dtype=dtype)
        if r is not None:
            data['R'][:] = r
        if p is not None:
            data['P'][:] = p
            
        instance = super(StateClassical, cls).__new__(cls)

        # Now we need to initialize the object, which typically happens in __init__
        # We'll manually call the initialization method, passing the arguments received by __new__
        instance.init_from_self = True
        instance.dim_classical = dim_classical
        instance.dim_quantum = dim_quantum
        instance.dtype = dtype
        instance.data = data
        
        return instance
        
    
    def __repr__(self) -> str:
        return f"""
    StateClassical(
        type: {self.dtype}, 
        dims_cl: {self.dim_classical}, 
        dims_qm: {self.dim_quantum}
    )
    """
    
 
        
class StateQuantum(State):
    def __init__(
        self, 
        dim_classical: int = None,
        dim_quantum: int = None,
        dtype: DTypeLike = None,
        data: ArrayLike = None,
        *args,
        **kwargs
    ) -> None:
        if self.init_from_self:
            super().__init__(self.dim_classical, self.dim_quantum, self.dtype, self.data)
            self.init_from_self = False
        else:
            super().__init__(dim_classical, dim_quantum, dtype, data)

    def __new__(
        cls,
        rho: Union[None, ArrayLike], 
        dim_quantum: int = None,
        *args, 
        **kwargs
    ) -> "StateQuantum":
        if "data" in kwargs and rho is None:
            return super(StateQuantum, cls).__new__(cls)
        
        dim_classical = None
        verify_quantum_dim(rho, dim_quantum)
        if rho is None and isinstance(dim_quantum, int) and (dim_quantum > 0):
            pass
            
        if rho is not None:
            dim_quantum = rho.shape[-1]
            
        dtype = [
            ('rho', np.complex128, (dim_quantum, dim_quantum))
        ]
        
        data = np.zeros(1, dtype=dtype)
        
        if rho is not None:
            data['rho'][:] = rho[:]
            
        instance = super(StateQuantum, cls).__new__(cls) 
        instance.init_from_self = True
        instance.dim_classical = dim_classical
        instance.dim_quantum = dim_quantum
        instance.dtype = dtype
        instance.data = data
        
        # return super(StateQuantum, cls).__new__(cls, dim_classical, dim_quantum, dtype, data)
        return instance
    
    def __repr__(self) -> str:
        return f"StateQuantum(dim={self.rho.shape})"
    

class StateMQC(State):
    
    def __init__(
        self,
        dim_classical: int = None,
        dim_quantum: int = None,
        dtype: DTypeLike = None,
        data: ArrayLike = None,
        *args,
        **kwargs
    ) -> None:
        if self.init_from_self:
            super().__init__(self.dim_classical, self.dim_quantum, self.dtype, self.data)
            self.init_from_self = False
        else:
            super(StateMQC, self).__init__(dim_classical, dim_quantum, dtype, data)
    
    def __new__(
        cls,
        r: Union[None, float, ArrayLike],
        p: Union[None, float, ArrayLike],
        rho: Union[None, ArrayLike],
        dim_classical: int = None,
        dim_quantum: int = None,
        *args,
        **kwargs
    ) -> "StateMQC":
        if "data" in kwargs and r is None and p is None and rho is None:
            return super(StateMQC, cls).__new__(cls) 
        
        verify_classical_dim(r, p, dim_classical)
        verify_quantum_dim(rho, dim_quantum)
        if r is None and p is None and dim_classical is None:
            raise ValueError("The classical part of the state cannot be determined.")
        
        if r is not None and isinstance(r, np.ndarray):
            dim_classical = r.shape[0]
        elif isinstance(r, float) or isinstance(r, int):
            dim_classical = 1
        else:
            raise TypeError(f"Invalid type of R: {type(r)}")
        
        if rho is None and dim_quantum is None:
            raise ValueError("The quantum part of the state cannot be determined.")
        
        if rho is not None:
            dim_quantum = rho.shape[0]
            
        dtype = [
            ('R', np.float64, dim_classical), 
            ('P', np.float64, dim_classical),
            ('rho', np.complex128, (dim_quantum, dim_quantum))
        ]
        
        data = np.zeros(1, dtype=dtype)
        if r is not None:
            data['R'][:] = r
        if p is not None:
            data['P'][:] = p
        if rho is not None:
            data['rho'][:] = rho
            
        instance = super(StateMQC, cls).__new__(cls)    
        instance.init_from_self = True
        instance.dim_classical = dim_classical
        instance.dim_quantum = dim_quantum
        instance.dtype = dtype
        instance.data = data
        
        return instance
        
     
    def __repr__(self) -> str:
        return f"StateMQC(type: {self.dtype}, dims_cl: {self.dim_classical}, dims_qm: {self.dim_quantum})"    
    
def zeros_like(s: State):
    return type(s)(
        r=None,
        p=None,
        rho=None,
        dim_classical=s.dim_classical,
        dim_quantum=s.dim_quantum,
        dtype=s.dtype,
        data=np.zeros(1, dtype=s.dtype)
    )

# %% The temporary code snippet for the main function
if __name__ == "__main__":
    rho = np.array([[1, 2], [2, 1]], dtype=np.complex128)
    s = StateMQC(r=1.0, p=2.0, rho=rho)
    # s = StateClassical(r=1.0, p=2.0)
    _2s = s + s
    # print(s.data)
    # print(s.data)
# %%
